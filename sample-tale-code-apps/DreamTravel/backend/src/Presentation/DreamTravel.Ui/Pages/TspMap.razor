@page "/tsp-map"
@using DreamTravel.Ui.Models
@using DreamTravel.Ui.Services
@using DreamTravel.Ui.Components.TspMap
@using DreamTravel.Ui.Components.Shared
@using DreamTravel.Trips.Domain.Cities
@using DreamTravel.Trips.Domain.Paths
@inject TspService TspService
@inject IJSRuntime JS
@inject ISnackbar Snackbar

<PageTitle>Dream Trips - TSP Solver</PageTitle>

<MudGrid Class="pa-0 ma-0">
    <MudItem xs="12" md="3" Class="pa-0">
        <CitiesPanel Cities="@_cities"
                     IsLoading="@_isCalculating"
                     TotalTime="@_totalTime"
                     TotalCost="@_totalCost"
                     OnCityAdded="HandleCityAdded"
                     OnCityRemoved="HandleCityRemoved"
                     OnCityChanged="HandleCityChanged"
                     OnRunTsp="HandleRunTsp" />
    </MudItem>

    <MudItem xs="12" md="9" Class="pa-0">
        <GoogleMap MapId="tsp-map"
                   EnableGeolocation="true"
                   EnableClickToAdd="true"
                   OnMapClick="HandleMapClick"
                   InitialZoom="5"
                   AdditionalStyles="height: calc(100vh - 64px);" />
    </MudItem>
</MudGrid>

@code {
    private List<CityEntry> _cities = new();
    private List<Path> _paths = new();
    private bool _isCalculating = false;
    private string _totalTime = "";
    private double _totalCost = 0;

    protected override void OnInitialized()
    {
        // Start with one empty city input
        _cities.Add(new CityEntry { Index = 0 });
    }

    private async Task HandleCityAdded()
    {
        _cities.Add(new CityEntry { Index = _cities.Count });
        StateHasChanged();
    }

    private async Task HandleCityRemoved(int index)
    {
        var city = _cities.FirstOrDefault(c => c.Index == index);
        if (city == null) return;

        _cities.Remove(city);

        // Clear marker from map if city was found
        if (city.City != null)
        {
            await ClearMap();
            await RerenderAllMarkers();
        }

        // Reindex remaining cities
        for (int i = 0; i < _cities.Count; i++)
        {
            _cities[i].Index = i;
        }

        StateHasChanged();
    }

    private async Task HandleCityChanged(CityEntry entry)
    {
        if (string.IsNullOrWhiteSpace(entry.Name)) return;

        _isCalculating = true;
        StateHasChanged();

        try
        {
            var result = await TspService.FindCityByNameAsync(entry.Name);

            if (result.IsSuccess)
            {
                entry.City = result.Data;
                await AddCityToMap(result.Data, entry.Index);
            }
            else
            {
                var errorMsg = result.Error?.Message ?? "City not found";
                Snackbar.Add(errorMsg, Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error finding city: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isCalculating = false;
            StateHasChanged();
        }
    }

    private async Task HandleMapClick(MapClickEventArgs args)
    {
        _isCalculating = true;
        StateHasChanged();

        try
        {
            var result = await TspService.FindCityByCoordinatesAsync(args.Lat, args.Lng);

            if (result.IsSuccess)
            {
                var entry = new CityEntry
                {
                    Index = _cities.Count,
                    City = result.Data,
                    Name = result.Data.Name
                };
                _cities.Add(entry);
                await AddCityToMap(result.Data, entry.Index);
            }
            else
            {
                var errorMsg = result.Error?.Message ?? "Failed to find city at location";
                Snackbar.Add(errorMsg, Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error finding city: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isCalculating = false;
            StateHasChanged();
        }
    }

    private async Task HandleRunTsp()
    {
        var validCities = _cities
            .Where(c => c.City != null)
            .Select(c => c.City!)
            .ToList();

        if (validCities.Count < 2)
        {
            Snackbar.Add("Please add at least 2 cities to calculate route", Severity.Warning);
            return;
        }

        _isCalculating = true;
        StateHasChanged();

        try
        {
            var result = await TspService.CalculateBestPathAsync(validCities);

            if (result.IsSuccess)
            {
                await ClearMap();
                await RenderOptimalPath(result.Data);
                CalculateTotals(result.Data.BestPaths);
                Snackbar.Add("TSP calculation completed!", Severity.Success);
            }
            else
            {
                var errorMsg = result.Error?.Message ?? "TSP calculation failed";
                Snackbar.Add(errorMsg, Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error calculating TSP: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isCalculating = false;
            StateHasChanged();
        }
    }

    private async Task AddCityToMap(City city, int index)
    {
        var label = (index + 1).ToString();
        await JS.InvokeVoidAsync("mapInterop.addTspMarker",
            "tsp-map",
            city.Latitude,
            city.Longitude,
            label,
            "#FF0000",
            new
            {
                name = city.Name,
                country = city.Country,
                searchStatistics = city.SearchStatistics
            });
    }

    private async Task RerenderAllMarkers()
    {
        for (int i = 0; i < _cities.Count; i++)
        {
            if (_cities[i].City != null)
            {
                await AddCityToMap(_cities[i].City, i);
            }
        }
    }

    private async Task ClearMap()
    {
        await JS.InvokeVoidAsync("mapInterop.clearTspMarkers", "tsp-map");
        await JS.InvokeVoidAsync("mapInterop.clearDirections", "tsp-map");
    }

    private async Task RenderOptimalPath(CalculateBestPathResult result)
    {
        // Update cities list with optimized order
        var optimizedCities = new List<CityEntry>();
        for (int i = 0; i < result.Cities.Count; i++)
        {
            optimizedCities.Add(new CityEntry
            {
                Index = i,
                Name = result.Cities[i].Name,
                City = result.Cities[i]
            });
        }
        _cities = optimizedCities;

        // Render cities in optimal order
        for (int i = 0; i < result.Cities.Count; i++)
        {
            await AddCityToMap(result.Cities[i], i);
        }

        // Render paths with color coding (blue=free, black=toll)
        foreach (var path in result.BestPaths)
        {
            var color = path.OptimalCost > 0 ? "black" : "#0080ff";
            var avoidTolls = path.OptimalCost == 0;

            try
            {
                await JS.InvokeVoidAsync("mapInterop.drawDirectionsPath",
                    "tsp-map",
                    path.StartingCity.Latitude,
                    path.StartingCity.Longitude,
                    path.EndingCity.Latitude,
                    path.EndingCity.Longitude,
                    new { color, avoidTolls });
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error drawing path: {ex.Message}");
            }
        }

        // Fit map to show all markers
        await JS.InvokeVoidAsync("mapInterop.fitBoundsToMarkers", "tsp-map");
    }

    private void CalculateTotals(List<Path> resultPaths)
    {
        _paths = resultPaths;

        var totalSeconds = resultPaths.Sum(p => p.OptimalDistance);
        _totalTime = TspService.FormatTimeFromSeconds(totalSeconds);

        // DKK conversion (7.46 multiplier from Angular app)
        _totalCost = resultPaths.Sum(p => p.OptimalCost) * 7.46;
    }
}
